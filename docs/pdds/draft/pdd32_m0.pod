# Copyright (C) 2001-2010, Parrot Foundation.

=head1 PDD 32: M0 Design Spec (atrodo's prototype)

=head2 Abstract

This document specifies M0, the set of microcode-like ops on which Parrot will
be based, and their requisite runtime environment.

This specific version of the spec defines how atrodo's current prototype
(https://github.com/atrodo/lorito) operates, not necessarily how the spec
going forward will be.

=head2 Definitions

define things here (M0, mop/6model)

=over 4

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These ops
are a subset of the C<M0> specification.

=item * Lorito

Lorito refers to the combination of C<M0>, a meta-object model and the way that
they're used as a foundation for Parrot.

=item * Lorito Context

This refers to a Lorito Context PMC, which is the most important data structure
at the M0 level. You could say that it is the "secret sauce" of M0. The exact
details of the Lorito Context PMC are still in flux.

=back

=head2 Design Goals

There are three goals that M0 needs to meet.  The first is that we have
executable code with equivalent power to C.  The second objective is to have a
form of code with can be easily analyzed.  The third goal is that we have a
single form of code used to implement the majority of Parrot, rather than
having having a mix of C and PIR.

We are also designing M0 to be minimally simple.  As much as possible, all the
complexity of Parrot will be built on top of M0.  This is to facilitate
multiple implementations, e.g. a quick and dirty prototype implementation in
JavaScript, a space-optimized implementation targeted for mobile devices, a
tracing jit targeted for server use, etc.

There will be no stacks in M0, not even for argument passing. Everything must
be in Continuation-Passing-Style.

=head2 Scope

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or layout of contexts, is
beyond its scope.

=head2 List of Ops

M0 ops are very low-level and provide the smallest necessary amount of
"syntax sugar" on top of the most basic operations of the VM.

The names and number of the ops below may change at any time, until the
spec is more stable.

=over

=item * noop

=item * end

=item * add

=item * sub

=item * mul

=item * div

=item * mod

=item * and

=item * or

=item * xor

=item * not

=item * shl

=item * shr

=item * iseq

=item * isgt

=item * isge

=item * goto

=item * if

=item * set

=item * load_const

=item * load_imm

=item * coerce_int

=item * coerce_num

=item * coerce_str

=item * new

=item * store

=item * load

=item * push_arg

=item * pop_arg

=item * call

=item * loadlib

=item * read

=item * write

=item * say

=item * gripe

=item * lookup

=item * ctx

=item * block

=item * new_ctx

=item * push_ret

=item * pop_ret

=item * cnt_ret

=item * cnt_arg

=item * hcf

=back

=head2 Textual Representation

  <goal> -> ( <any_code_blk> | <const_blk> | <struct_blk> )*
  <any_code_blk> -> ( <code_blk> | <init_blk> | <main_blk> ) <str> <stmt>* .end;
  <code_blk> -> .sub
  <init_blk> -> .init
  <main_blk> -> .main
  <const_blk> -> .const <str> <const_stmt>* .end;
  <struct_blk> -> ( .struct | .data ) <str> <struct_stmt>* .end;
  <stmt> -> <label>? <dest>? <regtype>? <opcode> ( <lhs> ( ,?  | , <rhs> ) )? ( : ( <imm> | <offset> | <jmp> ) )? ;
  <const_stmt> -> <label>? <const> ;
  <struct_stmt> -> <label>? size <int> ;
  <label> -> <id>? :
  <dest>  -> <reg> =
  <regtype> -> ( INT | NUM | STR | PMC )
  <opcode> -> [ @OPS ]
  <lhs> -> <reg>
  <rhs> -> <reg>
  <imm> -> <int>
  <jmp> -> <id>
  <offset> -> ( <str> | <id> )? [ <id> ( [+-] <int> )? ]
  <const> -> ( <num> | <int> | <str> )

  <str> ~> m/(?:') ([^']*(?:(?:\')[^']*)*) (?:')/xms
  <str> ~> m/(?:") ([^"]*(?:(?:\")[^"]*)*) (?:")/xms
  <int> ~> m/(\d+)/xms
  <num> ~> m/( [+-]? \d+ (?: [.] \d+)? (?: [+-]? [e] \d+)? )/xms
  <id>  ~> m/( [[:alpha:]] \w* )/xms
  <reg> ~> m/[$] [I | N | S | P]? ([\d]+)/xms

Above is a a grammar like description of the C<lasm> textual format.  In it's
basic form, it has 2 basic parts.

=over

=item * Blocks

Each C<lasm> file is a series of blocks.  Each block is either code, data
constant or structure.  Each block can be named.  Code blocks contains a series
of opcodes.  Data blocks are available to store data at runtime.  Constant
blocks store data at compile time.  The key difference between data and
constant blocks is the storage requirements.  Data blocks reserve space but
are not stored in an output file while constant blocks are written on output
and are immutable at runtime.  Structure blocks are syntactic sugar that allows
writers of C<lasm> files to reference offset locations by name instead of by
a number.

=item * Op statements

Each op statement has a single, basic structure.  It has:

=over

=item * Label

=item * Destination Register

=item * Op Type

=item * The Opcode

=item * Source #1 register

=item * Source #2 register

=item * An Immediate value, offset or jump location

=back

The only required portion of the statement is the opcode.  If Source #2 is
used, then Source #1 must also appear.

If the Op Type is omitted, PMC is used.  If a register is not give, register
0 is used.

=back

=head2 Binary Representation

Describe what the binary form of M0 will look like, including ops, constants
tables, debug segments, etc.  M0 being minimal, we should expect the binary
representation to remain stable once it's been finalized.

=head2 Binary instruction format

The binary instruction format is exactly 8 bytes long and has 6 parts.

=over

=item * Opcode type (2 bits)

=item * Opcode (6 bits)

=item * Destination Register (1 byte)

=item * Source #1 Register (1 byte)

=item * Source #2 Register (1 byte)

=item * Constant (4 bytes)

=back

That does mean that an opcode can only refer to 255 registers at a time.

=head2 metadata

describe metadata here, e.g. debugging information, aggregate op tracking info, whatever

=head2 Op Composition

if m0 needs to support op composition, describe it here

=head2 memory model

C<M0> only has access to memory associated with a PMC, everything except the
interp object is contained within a PMC.  There are several internal PMCs that
make up the basic memory "layout" of C<M0>.

=over

=item * CONTEXT

=item * FILE_BLOCK

=item * CODE_BLOCK

=item * CONST_BLOCK

=item * DATA_BLOCK

=item * C_METHOD

=back

The "root" of the C<M0> memory layout is the interp object.  It probably can be
thought of more accurarately as a "runcore" object.  It contains the currently
running context (as well as all PMCs that it created (not implemented yet)).

The file blocks are all the logical bytecode files loaded from the loadlib op.
Each file block has an array of code, constant and data blocks.  Code blocks
contain executable code.  Data blocks hold data available to manipulation to
the code blocks. Constant blocks hold the constants that can be loaded by the
load_const op.

The context objects are the actual executation units of C<M0>.  It contains
a program counter, code block, and constant block, the registers and an array
of arguments for passing into and out of the context.  It also contains an
optional context to return to implictly if it reaches the end of available ops
in the code block.

The C_Method is a special internal PMC that represents an external function
that is callable from within C<M0>

Directly from the interp object you can access the current context and all of
files blocks loaded.  From the file block, you can access all of the code,
constant and data blocks that were loaded with the file.

This layout also has the implicataion that the code execution is quite
encapsulated.  For instance since registers are tied to a context, and a
context is only associated with a single code block at a time, registers do not
leak between code blocks.

=head2 structs

describe structs here, as far as they're relevant to m0

=head2 Types

There are 4 basic types in C<M0>: INSP

=over

=item * Integer

=item * Number (Floating point number)

=item * PMC

=item * Symbol

=back

The PMC type is where most code will focus on.  A PMC is actually conceptually
identical to a chunk of memory with a little extra magic available.  It has
a data chunk of a particular size, a lookup method and a vtable PMC.

The data chunk is addressable and is available for any kind of manipulation
by C<M0> code.  Any basic type can be stored to or loaded from the data chunk,
including other PMCs.  There is a little bit of behind the scenes work to
encode and decode a PMC address into a data chunk so as to prevent malicious
access to the underlying implementation.  The value stored for a PMC into a
data chunk should be considered opaque.

The lookup method and vtable PMC are two special pieces of data stored
with the PMC.  When the lookup opcode is invoked, the lookup method is invoked
with the PMC and vtable.

In these ways, PMCs and Objects are identical and be treated as equal citizens.

A symbol is not a string.  It is an immutable, single instance data type.
Setting a register to 'foobar' will always point to a single instance of
the string 'foobar'.  This is bad performance for string manipulation, but
very good performance for string compares.

=head2 MOP interaction

C<M0> will come with a default MOP installed on all new PMC/Objects.  But,
because of the flexibility that the lookup opcode affords, the lookup method
can be changed to anything that conforms to the lookup method specification.

=head2 FFI

describe FFI here.  This will become especially important when we start
integrating Lorito with the rest of Parrot and want to be able to call into C
code from M0 and vice versa.

=head2 Concurrency

describe what primitives will be needed to allow data sharing and
synchronization between contexts.

=cut

__END__
Local Variables:
  fill-column:78
End: